"""
Tool for [TOOL_DESCRIPTION]
Generated for chemistry agent capabilities.
"""

import numpy as np
import pandas as pd
from typing import Union, List, Dict, Any, Optional
import json


def [MAIN_FUNCTION_NAME](
    [PARAMETER_1]: [TYPE_HINT],
    [PARAMETER_2]: [TYPE_HINT] = [DEFAULT_VALUE],
    **kwargs
) -> [RETURN_TYPE]:
    """
    [DETAILED_FUNCTION_DESCRIPTION]

    Args:
        [PARAMETER_1]: [Description of parameter 1]
        [PARAMETER_2]: [Description of parameter 2] (default: [DEFAULT_VALUE])
        **kwargs: Additional parameters

    Returns:
        [RETURN_TYPE]: [Description of what is returned]

    """
    try:
        # Input validation
        if not isinstance([PARAMETER_1], [EXPECTED_TYPE]):
            return {
                "success": False,
                "error": f"Expected {[EXPECTED_TYPE].__name__}, got {type([PARAMETER_1]).__name__}",
                "error_type": "TypeError"

        # Main logic here
        result = {
            "success": True,
            "data": [COMPUTED_RESULT],
            "metadata": {
                "tool_name": "[TOOL_NAME]",
                "parameters_used": {
                    "[PARAMETER_1]": [PARAMETER_1],
                    "[PARAMETER_2]": [PARAMETER_2]
                }
            }
        }

        return result

    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "error_type": type(e).__name__
        }


def [HELPER_FUNCTION_NAME]([PARAMS]) -> [RETURN_TYPE]:
    """
    [Helper function description]
    """
    # Helper function implementation
    pass


# Example usage (this won't execute when imported)
if __name__ == "__main__":
    # Test the function
    example_result = [MAIN_FUNCTION_NAME]([EXAMPLE_ARGS])
    print(json.dumps(example_result, indent=2))

## Tool:

A Tool is a Python function that does one single computation task, with a well-typed and documented input and output schema.

**Requirements:**

1. **Single Purpose**: The tool should not be over-complicated with multiple capabilities. If there are multiple separate jobs, there should be multiple separate tools.

2. **Stateless Computation**: The tool must have stateless computation logic. This means:
   - No global state usage
   - No modification of outer scope variables
   - Primary output via Python's `return` statement
   - No modification of input parameters
   - **File I/O Allowed:** Tools MAY write files (e.g., visualizations, results, intermediate files) IF:
     * File paths are provided as function parameters (not hardcoded)
     * All intermediate files use parametrized directory paths (e.g., `work_dir` parameter)
     * File paths are included in the return metadata
     * File writing is necessary for the tool's purpose (e.g., saving plots, generating reports)

3. **Error Handling**: The tool should not raise errors during execution. Instead, it should reflect errors in the return value through the standard return format.

4. **Return Format**: The tool must always return a dictionary with keys including but not limited to:
   - `"success"`: bool indicating if the operation succeeded
   - `"error"`: str or None containing error message if success is False
   - `"result"`: The actual result data (type depends on tool, None if error)
   - `"metadata"`: metadata about the call

**Key Points:**
- Never use `raise` statements - return error via dict
- Always validate inputs before processing
- Always validate outputs before returning
- Handle all exceptions and convert to error dict
- Keep functions pure and deterministic

## Key Requirements:

1. Function Structure:
  - Functions must NOT start with underscore (your system filters these out)
  - Include comprehensive docstrings with Args, Returns, and Raises sections
  - Use type hints for all parameters and return values

2. Return Format:
  - Always return a dictionary with "success" boolean
  - Include error handling with structured error responses
  - MUST NOT raise any error, return with "success": False instead
  - Provide metadata about the operation

3. File System Access:
  - Tools can read from the file system when parameters specify file paths
  - Tools can write files (plots, results, intermediate files) when paths are parametrized
  - All output file paths must be function parameters (e.g., `output_file: str`)
  - All intermediate files must use parametrized directories (e.g., `work_dir: str = "."`)
  - Include created file paths in return metadata
  - Handle FileNotFoundError and other I/O exceptions appropriately
  - Example:
    ```python
    def my_tool(data: str, output_file: str, work_dir: str = ".") -> Dict[str, Any]:
        import os
        # Intermediate file in parametrized directory
        checkpoint = os.path.join(work_dir, "temp.chk")
        # ... computation ...
        # Save result to parametrized output file
        with open(output_file, 'w') as f:
            f.write(result)
        return {
            "success": True,
            "result": result,
            "metadata": {
                "output_file": output_file,
                "checkpoint_file": checkpoint
            }
        }
    ```

4. Execution Guard:
  - Include if __name__ == "__main__": block for testing
  - No code should execute at module level during import
